import { Context, Markup } from 'telegraf'
import { IController } from './control.types'
import { rooms, Room, User } from '../rooms/rooms'
import { IRoom, IUser } from '../rooms/rooms.types'
import { Game } from '../game/game'
import { Card, ICard, IDeck, IGame, IGameCard, IGamePlayer } from '../game/game.types'
import * as Text from '../text'
import { IMessage } from '../types'
import { IPlayer } from '../players/players.types'
import { Player, players } from '../players/players'
import cards from '../data.json'
import { GamePlayer } from '../game/game-player'
import { InlineKeyboardButton } from 'telegraf/typings/core/types/typegram'
import { getField } from '../field/field'

export default class Controller implements IController {
    public createRoom(ctx: Context): void {
        if (!ctx) throw new Error('ctx is not defined!')

        const userId = ctx.from?.id as number

        const curRoom: IRoom | undefined = findRoomForUser(userId)
        if (curRoom !== undefined) {

            ctx.replyWithHTML(`üö´–í—ã —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ <b>${curRoom.name}</b>!`)
            return
        }

        const userName = ctx.from?.first_name as string
        const roomName: string = generateRandomRoomName()

        const player: IUser = new User(userId, userName)
        const newRoom: IRoom = new Room(roomName, player)

        rooms.push(newRoom)

        const replyText = `‚úÖ–ö–æ–º–Ω–∞—Ç–∞ –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>${roomName}</code> —Å–æ–∑–¥–∞–Ω–∞! –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ —Å—é–¥–∞ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞ –∏ –∑—Ä–∏—Ç–µ–ª–µ–π!\n\nüòÄ<i>–û–ø–ø–æ–Ω–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –≤–≤–µ—Å—Ç–∏ <code>/join ${roomName}</code>, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫–∞–∫ –∏–≥—Ä–æ–∫,\nü•∏–∑—Ä–∏—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –≤–≤–µ—Å—Ç–∏ <code>/watch ${roomName}</code>, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫–∞–∫ –∑—Ä–∏—Ç–µ–ª—å</i>`

        const menu = Markup.inlineKeyboard([
            [Markup.button.callback('–ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏', 'roominfo')],
            [Markup.button.callback('–£–¥–∞–ª–∏—Ç—å –∏ –≤—ã–π—Ç–∏', 'exit')]
        ])

        ctx.replyWithHTML(replyText, menu)
    }

    public joinRoom(ctx: Context, roomName: string, watcher = false): void {
        if (ctx.message != undefined) ctx.deleteMessage()

        if (roomName == undefined) {
            ctx.replyWithHTML('üö´<i>–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</i>')
            return
        }

        const room = rooms.find(r => r.name === roomName.trim())
        const userId = ctx.from?.id as number

        const curRoom: IRoom | undefined = findRoomForUser(userId)
        if (curRoom !== undefined) {
            ctx.replyWithHTML(`üö´<i>–í—ã —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ <b>${curRoom.name}</b>.</i>`)
            return
        }

        const userName = ctx.from?.first_name as string
        if (room?.players.findIndex(p => p.id === userId) !== -1) {
            ctx.replyWithHTML(`üö´<i>–ö–æ–º–Ω–∞—Ç—ã <b>${roomName}</b> –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.</i>`)
            return
        }

        const user: IUser = new User(userId, userName)

        const menu = Markup.inlineKeyboard([
            [Markup.button.callback('–ù–∞—á–∞—Ç—å –∏–≥—Ä—É', 'play')],
            [Markup.button.callback('–ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏', 'roominfo')],
            [Markup.button.callback('–í—ã–π—Ç–∏', 'exit')]
        ])

        if (room.players.length < 2 && !watcher) {

            room.players.push(user)
            ctx.replyWithHTML(`üòÄ–í—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–º–Ω–∞—Ç—É <b>${room.name}</b> –∫–∞–∫ –∏–≥—Ä–æ–∫! –ü—Ä–∏—è—Ç–Ω–æ–π –∏–≥—Ä—ã!`, menu)

            room.informRoom(ctx, 'pjoin', user)
        } else {

            room.watchers.push(user)
            ctx.replyWithHTML(`ü•∏–í—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–º–Ω–∞—Ç—É <b>${room.name}</b> –∫–∞–∫ –∑—Ä–∏—Ç–µ–ª—å.`, menu)

            room.informRoom(ctx, 'wjoin', user)
        }
    }

    public leaveRoom(ctx: Context): void {
        if (ctx.message != undefined) ctx.deleteMessage()

        const userId = ctx.from?.id as number
        const curRoom: IRoom | undefined = findRoomForUser(userId)

        if (curRoom === undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
        } else {

            const userStatusArr = curRoom.players.findIndex(u => u.id === userId) !== -1 ? curRoom.players : curRoom.watchers as IUser[]
            const userIndex = userStatusArr.findIndex(u => u.id === userId)

            curRoom.informRoom(ctx, 'exit', userStatusArr[userIndex])

            userStatusArr.splice(userIndex, 1)

            ctx.replyWithHTML(`üö™–í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –∫–æ–º–Ω–∞—Ç—É <b>${curRoom.name}</b>`)
            if (curRoom.players.length === 0 && curRoom.watchers.length === 0) rooms.splice(rooms.indexOf(curRoom), 1)
        }
    }

    public showRoom(ctx: Context): void {
        if (ctx.message != undefined) ctx.deleteMessage()

        const userId = ctx.from?.id as number
        const curRoom: IRoom | undefined = findRoomForUser(userId)

        if (curRoom === undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
        } else {
            const menu = Markup.inlineKeyboard([[Markup.button.callback('–í—ã–π—Ç–∏', 'exit')], [Markup.button.callback('–ó–∞–∫—Ä—ã—Ç—å', 'close')]])

            const playersInRoom = curRoom.players.map(p => p.name)
            const watchersInRoom = curRoom.watchers.map(w => w.name)

            const players = playersInRoom.length ? `üòÄ${playersInRoom.join('\nüòÄ')}` : 'üö´<i>–ò–≥—Ä–æ–∫–æ–≤ –Ω–µ—Ç</i>üö´'
            const watchers = watchersInRoom.length ? `ü•∏${watchersInRoom.join('\nü•∏')}` : 'üö´<i>–ó—Ä–∏—Ç–µ–ª–µ–π –Ω–µ—Ç</i>üö´'
            const isOnGame = curRoom.status ? '‚úÖ–ò–≥—Ä–∞ –∏–¥–µ—Ç‚úÖ' : 'üö´–ò–≥—Ä–∞ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å / —É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—åüö´'

            const message = `üì∞<b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–æ–º–Ω–∞—Ç–µ</b> <code>${curRoom.name}</code>\nüóû<b>–í–ª–∞–¥–µ–ª–µ—Ü</b> - ${playersInRoom[0]}\n\n<b>–ò–≥—Ä–æ–∫–∏:</b>\n${players}\n\n<b>–ó—Ä–∏—Ç–µ–ª–∏:</b>\n${watchers}\n\n<b>–°—Ç–∞—Ç—É—Å –∏–≥—Ä—ã:</b> ${isOnGame}`
            ctx.replyWithHTML(message, menu)
        }
    }

    public showAllRooms(ctx: Context): void {
        if (ctx.message != undefined) ctx.deleteMessage()

        const roomNames = rooms.map(room => `<code>${room.name}</code>`)
        const list = roomNames.length === 0 ? '<i>üö´–î–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–Ω–∞—Ç –Ω–µ—Çüö´</i>' : `üóû${roomNames.join('\nüóû')}`
        const message = `üì∞<b>–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–Ω–∞—Ç:</b>\n\n${list}`

        ctx.replyWithHTML(message, Markup.inlineKeyboard([Markup.button.callback('–ó–∞–∫—Ä—ã—Ç—å', 'close')]))
    }

    public prepareGame(ctx: Context): void {
        if (ctx.message != undefined) ctx.deleteMessage()

        const userId = ctx.from?.id as number
        const curRoom: IRoom | undefined = findRoomForUser(userId)

        if (curRoom == undefined) {

            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
            return
        } else if (!isPlayer(userId, curRoom)) {

            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        if (curRoom.isOnGame) return

        // if (curRoom.players.length !== 2) {
        //     ctx.replyWithHTML('üö´<i>–ò–≥—Ä–æ–∫–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–≤–æ–µ.</i>')
        //     return
        // }

        curRoom.isOnGame = true
        curRoom.watchers.forEach(async (u) => {
            ctx.telegram.sendMessage(u.id, 'üó°–ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞!üõ°')
        })

        const game: IGame = new Game(curRoom)
        curRoom.game = game

        game.changeStatus('lobby')
        this.requireDecks(ctx, curRoom)
    }

    public sendMessage(ctx: Context): void {
        const userId = ctx.from?.id as number
        const userName = ctx.from?.first_name as string

        const curRoom: IRoom | undefined = findRoomForUser(userId)

        if (curRoom !== undefined) {
            curRoom.informRoom(ctx, 'msg', new User(userId, userName))
        }
    }

    public requireDecks(ctx: Context, room: IRoom): void {

        room.players.forEach(user => {
            const { message, menu } = this.printDecks(user.id)

            ctx.telegram.sendMessage(user.id, message, { parse_mode: 'HTML', reply_markup: Markup.inlineKeyboard(menu).reply_markup })
        })
    }

    public requireDecklist(ctx: Context) {
        const menu = [[Markup.button.callback('–û—Ç–º–µ–Ω–∞', 'cancel_add-deck')]]
        ctx.editMessageText(Text.requireDecklistMessage, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
    }

    public addDeck(ctx: Context) {
        const message = ctx.message as IMessage
        const messageText = message.text

        let deck: IDeck
        try {
            deck = this.parseDecklist(messageText)
        } catch (e) {
            ctx.reply(Text.deckErrorMessage)
            return
        }


        if (deck.count < 30) {
            ctx.reply(Text.deckErrorMessage)
            return
        }

        const userId = ctx.from?.id
        if (!userId) throw new Error('Cannot find user id')

        let player: IPlayer | undefined = findPlayerById(userId)

        if (player == undefined) {
            player = new Player(userId)
            players.push(player)
        }

        if (player.decks.findIndex(d => d.name === deck.name) !== -1) {
            ctx.replyWithHTML(`üö´<i>–ö–æ–ª–æ–¥–∞ —Å –∏–º–µ–Ω–µ–º <b>${deck.name}</b> —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!</i>`)
            return
        }

        for (const card of deck.list) {
            if (cards.findIndex((c) => c.name.toLowerCase() === card.name.toLowerCase()) === -1) {
                ctx.replyWithHTML(`üö´<i>–ö–∞—Ä—Ç–∞ <b>${card.name}</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!</i>`)
                return
            }
        }

        const decklist = deck.list.map((card: ICard) => `${card.count} ${card.name}`).join(',\n')
        const room = findRoomForUser(userId)

        if (room == undefined || room.game == undefined || room.game.status !== 'lobby') {
            ctx.replyWithHTML(`üÉè–ö–æ–ª–æ–¥–∞ <b>${deck.name}</b> –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n<b>–î–µ–∫–ª–∏—Å—Ç:</b>\n<code>${decklist}</code>\n\n<b>–í—Å–µ–≥–æ –∫–∞—Ä—Ç:</b> ${deck.count}`)
        } else {

            const menu = Markup.inlineKeyboard([
                [
                    Markup.button.callback('üîô–ù–∞–∑–∞–¥', 'cancel_add-deck'),
                    Markup.button.callback('üéÆ–ò–≥—Ä–∞—Ç—å', `choose-deck_${deck.name}`)
                ]
            ])

            ctx.replyWithHTML(`üÉè–ö–æ–ª–æ–¥–∞ <b>${deck.name}</b> –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n\n<b>–î–µ–∫–ª–∏—Å—Ç:</b>\n<code>${decklist}</code>\n\n<b>–í—Å–µ–≥–æ –∫–∞—Ä—Ç:</b> ${deck.count}`, menu)
        }

        console.log(deck)
        player.decks.push(deck)
    }

    public printDecks(id: number) {
        const player = findPlayerById(id)

        const deckButtonsArr = player == undefined ? [] : player.decks.map((deck) => [Markup.button.callback(`üÉè${deck.name}`, `choose-deck_${deck.name}`)])

        const menu = deckButtonsArr.concat([
            [Markup.button.callback('‚ûï–î–æ–±–∞–≤–∏—Ç—å –∫–æ–ª–æ–¥—É', 'add_deck')],
        ])
        // const decksList = p !== undefined ? `${p.decks.map(d => `üÉè<code>/deck ${d.name}</code>`).join('\n')}` : 'üö´<i>–ö–æ–ª–æ–¥ –Ω–µ—Ç</i>üö´'
        const message = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—É:'

        return { message, menu }
    }

    public async chooseDeck(ctx: Context, deckName: string) {
        const userId = ctx.from?.id
        const userName = ctx.from?.first_name
        if (userId == undefined || userName == undefined) throw new Error('user not founded')

        let player = players.find(p => p.id === userId)

        if (player == undefined) {
            player = new Player(userId)
            players.push(player)
        }

        const room = findRoomForUser(userId)
        if (room == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ</i>')
            return
        }

        const game = room.game
        if (game == undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞</i>')
            return
        }

        const deck = player.decks.find(deck => deck.name === deckName)
        if (deck == undefined) {
            ctx.replyWithHTML('üö´<i>–ö–æ–ª–æ–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</i>')
            return
        }

        if (game.players.findIndex(p => p.id === userId) !== -1) {
            ctx.replyWithHTML('üö´<i>–í—ã —É–∂–µ –≤ –∏–≥—Ä–µ</i>')
            return
        }

        game.players.push(new GamePlayer(userId, userName, deck))

        await ctx.replyWithHTML(`‚úÖ–ö–æ–ª–æ–¥–∞ <b>${deck.name}</b> –≤—ã–±—Ä–∞–Ω–∞ –¥–ª—è –∏–≥—Ä—ã!`)
        room.informRoom(ctx, 'deck', new User(userId, userName))

        if (game.players.length === 2) game.startGame(ctx)
    }

    public generateHand(player: IGamePlayer): Card[] {
        const { deck } = player
        const deckSet: string[] = deck.list.map((card: ICard) => new Array(card.count).fill(card.name)).reduce((a, c) => a.concat(c), [])

        const handSet = this.generateHandSet(deckSet)
        const hand = this.parseHand(handSet)

        return hand
    }

    public parseCard(cardObj: Card | string, isFull = false): string {
        let card = cardObj

        if (typeof card === 'string') {
            card = this.findCardByName(cardObj as string) as Card
        }

        const cardCost = card.elite ? 'üî∂' + card.cost : 'üî∑' + card.cost
        const cardName = `<b>${card.name}</b>`

        let cardElement;

        switch (card.element.toLowerCase().trim()) {
            case '—Å—Ç–µ–ø–∏':
                cardElement = isFull ? '‚òÄÔ∏è' + card.element : '‚òÄÔ∏è'
                break;
            case '–ª–µ—Å–∞':
                cardElement = isFull ? 'üå≥' + card.element : 'üå≥'
                break;
            case '–≥–æ—Ä—ã':
                cardElement = isFull ? 'üóª' + card.element : 'üóª'
                break;
            case '–±–æ–ª–æ—Ç–æ':
                cardElement = isFull ? 'üåæ' + card.element : 'üåæ'
                break;
            case '—Ç—å–º–∞':
                cardElement = isFull ? 'üíÄ' + card.element : 'üíÄ'
                break;
            default:
                cardElement = isFull ? '‚öî' + card.element : '‚öî'
        }

        const cardHead = [cardCost, cardName, cardElement].join('  ')

        if (!isFull) return cardHead

        const cardClass = `‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî${card.class ? card.class : '‚Äî‚Äî‚Äî‚Äî'}‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî`

        const cardLife = `{${card.stats.lifeCount}‚ù§Ô∏è}`
        const cardWalk = `{${card.stats.walkCount}üêæ}`
        const cardHit = `{${card.stats.simpleHit}üó°}`

        const cardStats = `======<b>${cardLife}</b>==<b>${cardWalk}</b>==<b>${cardHit}</b>======`

        const cardAbilities = card.abilities ? card.abilities.replaceAll('|', '\n') : ''

        const cardDescription = card.description ? `\n<i>${card.description.replaceAll('|', '\n')}</i>` : ''

        let cardRarity;
        switch (card.rarity.toLowerCase().trim()) {
            case '—á–∞—Å—Ç–∞—è':
                cardRarity = 'üü¢ ' + card.rarity
                break;
            case '–Ω–µ–æ–±—ã—á–Ω–∞—è':
                cardRarity = 'üîµ ' + card.rarity
                break;
            case '—Ä–µ–¥–∫–∞—è':
                cardRarity = 'üü£ ' + card.rarity
                break;
            case '—É–ª—å—Ç—Ä–∞—Ä–µ–¥–∫–∞—è':
                cardRarity = 'üü† ' + card.rarity
                break;
        }

        const cardString = [cardHead, cardClass, cardStats, cardAbilities, cardDescription, `${card.index} <b>${card.set}</b> ${cardRarity}`].join('\n')

        return cardString
    }

    public addCardToSquad(ctx: Context, name: string) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        if (!player.game?.areHandsKeeped) {
            ctx.replyWithHTML('üö´<i>–ï—â–µ –Ω–µ –≤—Å–µ –æ—Å—Ç–∞–≤–∏–ª–∏ —Å–≤–æ–∏ —Ä—É–∫–∏</i>')
            return
        }

        const menu = [
            [Markup.button.callback('üîô–û—Ç–º–µ–Ω–∞', `cancel_squad-${name}`)]
        ]

        const cardInfoArr = this.parseCard(name).split(' ')
        const cardElement = cardInfoArr[cardInfoArr.length - 1]
        const cardCost = cardInfoArr[0]
        ctx.editMessageCaption(`–ö–∞—Ä—Ç–∞ ${cardElement}<b>${name}</b>(${cardCost}) –≤–∑—è—Ç–∞ –≤ –æ—Ç—Ä—è–¥!`, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })


        const card = this.findCardByName(name)
        if (card == undefined) throw new Error('Card not found')

        if (card.stats.walkCount.toLowerCase().trim() === '–ø–æ–ª–µ—Ç') {
            player.squad.fliers.push(card)
        } else {
            player.squad.field.push(card)
        }

        this.showCurrentSquad(ctx, player)
    }

    public keepHand(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        ctx.deleteMessage().catch(e => e)

        if (player.squad.isHandKeeped) {
            ctx.replyWithHTML('üö´<i>–í—ã —É–∂–µ –æ—Å—Ç–∞–≤–∏–ª–∏ —Ä—É–∫—É</i>')
            return
        }

        const game = player.game
        if (game == undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å/—É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å</i>')
            return
        }

        const room = game.room

        player.squad.isHandKeeped = true

        const isReady: boolean = room.game?.players.reduce((prev, curr) => !prev ? prev : curr.squad.isHandKeeped, true) as boolean
        if (isReady) game.areHandsKeeped = true

        room.players.concat(room.watchers).forEach(user => {
            if (isReady) {
                user.id === player.id ?
                    ctx.telegram.sendMessage(user.id, `‚úÖ–í—ã –æ—Å—Ç–∞–≤–∏–ª–∏ —Ä—É–∫—É.\n–ù–∞–±–∏—Ä–∞–π—Ç–µ –æ—Ç—Ä—è–¥ –∏ —Ä–∞—Å—Å—Ç–∞–≤–ª—è–π—Ç–µ.`, { parse_mode: 'HTML' })
                    : ctx.telegram.sendMessage(user.id, `‚úÖ<b>${player.name}</b> –æ—Å—Ç–∞–≤–∏–ª —Ä—É–∫—É.\n–ù–∞–±–∏—Ä–∞–π—Ç–µ –æ—Ç—Ä—è–¥ –∏ —Ä–∞—Å—Å—Ç–∞–≤–ª—è–π—Ç–µ.`, { parse_mode: 'HTML' })
            } else {
                user.id === player.id ?
                    ctx.telegram.sendMessage(user.id, `‚úÖ–í—ã –æ—Å—Ç–∞–≤–∏–ª–∏ —Ä—É–∫—É. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö, –ø—Ä–µ–∂–¥–µ —á–µ–º –Ω–∞–±–∏—Ä–∞—Ç—å –æ—Ç—Ä—è–¥.`, { parse_mode: 'HTML' })
                    : ctx.telegram.sendMessage(user.id, `‚úÖ<b>${player.name}</b> –æ—Å—Ç–∞–≤–∏–ª —Ä—É–∫—É.`, { parse_mode: 'HTML' })
            }
        })
    }

    public async mulliganHand(ctx: Context) {
        this.deleteLastSquad(ctx)
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        player.handMessages = []
        player.squad.field = []
        player.squad.fliers = []
        player.squad.crystals.gold--
        player.squad.arrangingIndex = 0
        player.squad.arrangingArr = []
        player.squad.startArrangement = [new Array(5).fill(null), new Array(5).fill(null), new Array(5).fill(null)]

        const hand: Card[] = this.generateHand(player)

        await ctx.reply('ü§ö–ù–æ–≤–∞—è —Ä—É–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞!')
        new Promise((resolve) => {
            hand.forEach(async (card) => {

                const menu = [
                    [Markup.button.callback('‚ûï–í–∑—è—Ç—å –≤ –æ—Ç—Ä—è–¥', `squad_${card.name}`)],
                    [Markup.button.callback('üëÅ –ü–æ–∫–∞–∑–∞—Ç—å', `show_${card.name}`)],
                ]

                await ctx.replyWithPhoto(card.image, { caption: this.parseCard(card), parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
                    .then((res) => {
                        player.handMessages.push(res.message_id)
                    })
                if (player.handMessages.length === hand.length) resolve(1)
            })
        })
            .then(() => {

                const menu = [
                    [
                        Markup.button.callback('ü§ö–û—Å—Ç–∞–≤–∏—Ç—å', `keep-hand`),
                        Markup.button.callback('üîÄ–ü–µ—Ä–µ—Å–¥–∞—Ç—å', `mulligan`)
                    ]
                ]

                ctx.reply('üÉè–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–æ–æ–±—â–∏—Ç–µ, —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ —Ä—É–∫—É –ø–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –Ω–∞–±–∏—Ä–∞—Ç—å –æ—Ç—Ä—è–¥:', { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
                    .then((res) => {
                        player.handMessages.push(res.message_id)
                    })
            })
            .then(() => {
                const game = player.game
                if (game == undefined) {
                    ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å</i>')
                    return
                }

                game.room.players.concat(game.room.watchers).forEach(user => {
                    ctx.telegram.sendMessage(user.id, `üîÄ${user.id === player.id ? '–í—ã –ø–µ—Ä–µ—Å–¥–∞–ª–∏' : `<b>${player.name}</b> –ø–µ—Ä–µ—Å–¥–∞–ª`} —Ä—É–∫—É`, { parse_mode: 'HTML' })
                })
            })
    }

    private async deleteLastSquad(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const squadMessagesIds = player.handMessages
        squadMessagesIds.forEach(id => {
            ctx.deleteMessage(id).catch((e) => { return e })
        })
    }

    public deleteCardFromSquad(ctx: Context, name: string) {
        const userId = ctx.chat?.id
        if (userId == undefined) throw new Error('User not found')

        const room = findRoomForUser(userId)
        if (room == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
            return
        }

        const game = room.game
        if (game === undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.</i>')
            return
        }

        const player = game.players.find(player => player.id === userId)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const card = this.findCardByName(name)
        if (card == undefined) throw new Error('Card not found')

        const squadArr = card.stats.walkCount.toLowerCase().trim() === '–ø–æ–ª–µ—Ç' ? player.squad.fliers : player.squad.field

        const cardIndex = squadArr.findIndex(card => card.name === name)

        if (cardIndex !== -1) {
            squadArr.splice(cardIndex, 1)
        }

        this.showCurrentSquad(ctx, player)
    }

    private showCurrentSquad(ctx: Context, player: IGamePlayer) {
        if (player.handMessages.length < 16) return

        const playerCurrentSquad: (Card | void)[] = player.squad.field.concat(player.squad.fliers).map(({ name }) => this.findCardByName(name))

        const playerCurrentSquadStr: string = playerCurrentSquad.map(card => {
            if (card == undefined) {
                throw new Error('Card not found')
            }

            const cardCost = card.elite ? 'üî∂' + card.cost : 'üî∑' + card.cost

            let cardElement
            switch (card.element.toLowerCase().trim()) {
                case '—Å—Ç–µ–ø–∏':
                    cardElement = '‚òÄÔ∏è'
                    break;
                case '–ª–µ—Å–∞':
                    cardElement = 'üå≥'
                    break;
                case '–≥–æ—Ä—ã':
                    cardElement = 'üóª'
                    break;
                case '–±–æ–ª–æ—Ç–æ':
                    cardElement = 'üåæ'
                    break;
                case '—Ç—å–º–∞':
                    cardElement = 'üíÄ'
                    break;
                default:
                    cardElement = '‚öî'
            }

            return `${cardCost} ${card.name} ${cardElement}`
        }).join('\n')

        const playerSquadElements: string[] = []
        let gold: number = player.squad.crystals.gold
        let silver: number = player.squad.crystals.silver

        playerCurrentSquad.forEach(card => {
            if (card == undefined) {
                throw new Error('Card not found')
            }

            card.elite ? gold -= card.cost : silver -= card.cost

            if (playerSquadElements.indexOf(card.element) === -1) {
                if (playerSquadElements.length) {
                    gold--
                }

                playerSquadElements.push(card.element)
            }
        })


        const menu = [
            [
                Markup.button.callback('üó∫–†–∞—Å—Å—Ç–∞–≤–∏—Ç—å', `arrange-squad`)
            ]
        ]


        if (player.handMessages.length < 17) {
            ctx.replyWithHTML(`${playerCurrentSquadStr.trim() ? '–í–∞—à —Ç–µ–∫—É—â–∏–π –æ—Ç—Ä—è–¥:\n' + playerCurrentSquadStr : ''}\n\n–ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –æ—Å—Ç–∞–ª–æ—Å—å: ${gold}üî∂, ${silver}üî∑\n\nüÉè–†–∞—Å—Å—Ç–∞–≤–∏—Ç—å:`, { reply_markup: { inline_keyboard: menu } })
                .then(m => player.handMessages.push(m.message_id))
        } else {
            ctx.telegram.editMessageText(ctx.from?.id, player.handMessages[player.handMessages.length - 1], undefined, `${playerCurrentSquadStr.trim() ? '–í–∞—à —Ç–µ–∫—É—â–∏–π –æ—Ç—Ä—è–¥:\n' + playerCurrentSquadStr : ''}\n\n–ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –æ—Å—Ç–∞–ª–æ—Å—å: ${gold}üî∂, ${silver}üî∑\n\nüÉè–†–∞—Å—Å—Ç–∞–≤–∏—Ç—å:`, { reply_markup: { inline_keyboard: menu } })
                .catch(e => e)
        }
    }

    public startArranging(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        if (!player.squad.field.concat(player.squad.fliers).length) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞–±—Ä–∞–ª–∏ –æ—Ç—Ä—è–¥!</i>')
            return
        }

        this.deleteLastSquad(ctx)

        const playerSquad = player.squad.field.concat(player.squad.fliers).map(({ name }, index) => { return { name, index: index + 1 } })
        player.squad.arrangingArr = playerSquad

        const { message, menu } = this.arrange(ctx, 1)
        if (message == undefined || menu == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        ctx.replyWithHTML(message, Markup.inlineKeyboard(menu)).then(m => {
            player.handMessages.push(m.message_id)
        })
    }

    public arrangeCard(ctx: Context, cellId: string) {

        if (ctx.callbackQuery == undefined) {
            throw new Error('Message not found')
        }

        const messageObj: IMessage = ctx.callbackQuery.message as IMessage
        const text = messageObj.text

        const cardName = text.split('\n').find(str => str.startsWith('‚û°Ô∏è'))?.split(')').slice(1).join('').toLowerCase().trim()
        if (cardName == undefined) {
            return
        }

        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const arrangingArr = player.squad.arrangingArr
        if (arrangingArr == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const cellNumber = Number(cellId.split('_')[1])
        const row = Math.floor(cellNumber / 5)
        const cell = cellNumber % 5

        if (player.squad.startArrangement[row][cell]) {
            return
        }

        let indicator = false;
        player.squad.startArrangement.forEach(arr => arr.forEach(card => { if (Number(card?.arrIndex) === player.squad.arrangingIndex) indicator = true }))

        if (indicator) {
            const rowIndex = player.squad.startArrangement.findIndex(arr => arr.findIndex(c => c ? c.arrIndex === player.squad.arrangingIndex : false) !== -1)
            const cellIndex = player.squad.startArrangement[rowIndex].findIndex(c => c ? c.arrIndex === player.squad.arrangingIndex : false)

            player.squad.startArrangement[rowIndex][cellIndex] = null
        } else {
            // ctx.replyWithHTML(`<code>–î–æ:</code>${JSON.stringify(player.squad.startArrangement.map(arr => arr.map(c => c ? `${c.name}(${c.arrIndex})` : '‚¨úÔ∏è')))}`)

            arrangingArr.splice(arrangingArr.findIndex(c => c.index === player.squad.arrangingIndex), 1)
        }

        const card = this.findCardByName(cardName) as Card
        card.arrIndex = player.squad.arrangingIndex

        player.squad.startArrangement[row][cell] = card

        const { message, menu } = this.arrange(ctx, player.squad.arrangingIndex !== undefined ? player.squad.arrangingIndex : 0)

        if (message == undefined || menu == undefined) {
            throw new Error('Message is undefined')
        }
        // ctx.replyWithHTML(`<code>–ü–æ—Å–ª–µ:</code>${JSON.stringify(player.squad.startArrangement.map(arr => arr.map(c => c ? `${c.name}(${c.arrIndex})` : '‚¨úÔ∏è')))}`)
        ctx.editMessageText(message, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
    }

    public arrangeNext(ctx: Context) {
        const messageObj: IMessage = ctx.callbackQuery?.message as IMessage
        const text = messageObj.text
        const cardNameIndex = text.split('\n').findIndex(str => str.startsWith('‚û°Ô∏è'))

        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        if (cardNameIndex === text.split('\n').length - 3) {

            player.game?.finishArranging(ctx)
            return
        }

        player.squad.arrangingIndex = player.squad.arrangingIndex as number + 1

        const { message, menu } = this.arrange(ctx, player.squad.arrangingIndex)

        if (message == undefined || menu == undefined) {
            throw new Error('Message is undefined')
        }

        ctx.editMessageText(message, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
    }

    public arrangePrev(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        player.squad.arrangingIndex = player.squad.arrangingIndex as number - 1

        const { message, menu } = this.arrange(ctx, player.squad.arrangingIndex)

        if (message == undefined || menu == undefined) {
            throw new Error('Message is undefined')
        }

        ctx.editMessageText(message, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
    }

    public defineTurnOrder(ctx: Context, isFirst: boolean) {

        ctx.deleteMessage()

        const userId = ctx.chat?.id
        if (userId == undefined) throw new Error('User not found')

        const player = this.findGamePlayerByCtx(ctx)

        const room = findRoomForUser(userId)
        if (room == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
            return
        }

        const game = room.game
        if (game === undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.</i>')
            return
        }

        game.players = game.players[0].id === userId && !isFirst || game.players[0].id !== userId && isFirst ? game.players.reverse() : game.players

        const menu = [
            [Markup.button.callback('üÉè–í–∑—è—Ç—å 15 –∫–∞—Ä—Ç', 'draw-hand')]
        ]

        room.players.concat(room.watchers).forEach(user => {
            user.id === userId ?
                ctx.telegram.sendMessage(user.id, `üé≤–í—ã —Ö–æ–¥–∏—Ç–µ ${isFirst ? '–ø–µ—Ä–≤—ã–º' : '–≤—Ç–æ—Ä—ã–º'}.`, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
                : ctx.telegram.sendMessage(user.id, `üé≤<b>${player?.name}</b> —Ö–æ–¥–∏—Ç ${isFirst ? '–ø–µ—Ä–≤—ã–º' : '–≤—Ç–æ—Ä—ã–º'}.`, { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } })
        })

    }

    public async drawHand(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const hand = this.generateHand(player)
        await ctx.telegram.sendMessage(player.id, 'üÉè–í–∞—à–∞ —Ä—É–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞!')
        new Promise((resolve) => {
            hand.forEach(async (card) => {

                const menu = [
                    [Markup.button.callback('‚ûï–í–∑—è—Ç—å –≤ –æ—Ç—Ä—è–¥', `squad_${card.name}`)],
                    [Markup.button.callback('üëÅ –ü–æ–∫–∞–∑–∞—Ç—å', `show_${card.name}`)],
                    // Markup.button.callback('‚ùî', `info_${card.name}`)
                ]

                ctx.telegram.sendPhoto(player.id, card.image, { parse_mode: 'HTML', caption: this.parseCard(card), reply_markup: { inline_keyboard: menu } })
                    .then((res) => {
                        player.handMessages.push(res.message_id)
                    })
                    .then(() => {
                        if (player.handMessages.length === hand.length) resolve(1)
                    })
            })
        })
            .then(() => {

                const menu = [
                    [
                        Markup.button.callback('ü§ö–û—Å—Ç–∞–≤–∏—Ç—å', `keep-hand`),
                        Markup.button.callback('üîÄ–ü–µ—Ä–µ—Å–¥–∞—Ç—å', `mulligan`)
                    ]
                ]

                ctx.telegram.sendMessage(player.id, 'üÉè–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–æ–æ–±—â–∏—Ç–µ, —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ —Ä—É–∫—É –ø–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –Ω–∞–±–∏—Ä–∞—Ç—å –æ—Ç—Ä—è–¥:', { parse_mode: 'HTML', reply_markup: { inline_keyboard: menu } }).then(m => {
                    player.handMessages.push(m.message_id)
                })
            })
    }

    public showCard(ctx: Context, name: string) {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const game = player.game
        if (game == undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.</i>')
            return
        }

        if (!game.areHandsKeeped) {
            ctx.replyWithHTML('üö´<i>–ï—â–µ –Ω–µ –≤—Å–µ –æ—Å—Ç–∞–≤–∏–ª–∏ —Å–≤–æ–∏ —Ä—É–∫–∏</i>')
            return
        }

        ctx.replyWithHTML(`üëÅ–í—ã –ø–æ–∫–∞–∑–∞–ª–∏ –æ–ø–ø–æ–Ω–µ–Ω—Ç—É –∫–∞—Ä—Ç—É <b>${name}</b>`)

        const opponentPlayer = game.players.find(p => p.id !== player.id) as IGamePlayer

        const card = this.findCardByName(name)
        if (card == undefined) {
            ctx.replyWithHTML(`üö´<i>–ö–∞—Ä—Ç–∞ <b>${name}</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!</i>`)
            return
        }

        ctx.telegram.sendPhoto(opponentPlayer.id, card.image, { caption: 'üëÅ–û–ø–ø–æ–Ω–µ–Ω—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤–∞–º –∫–∞—Ä—Ç—É:' })
    }

    public passTurn(ctx: Context) {
        const player = this.findGamePlayerByCtx(ctx)

        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const game = player.game as IGame

        game.endTurn(ctx)
    }

    private arrange(ctx: Context, currentIndex: number): { message: string | undefined, menu: InlineKeyboardButton[][] | undefined } {
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return { message: undefined, menu: undefined }
        }

        const arrangingArr = player.squad.arrangingArr
        if (arrangingArr == undefined) {
            throw new Error('Arranging arr not found')
        }

        player.squad.arrangingIndex = currentIndex

        const playerSquad = player.squad.field.concat(player.squad.fliers).map(({ name }, index) => { return { name, index: index + 1 } })

        const playerSquadStr = playerSquad.map((card, index) => index !== currentIndex - 1 ? (arrangingArr.findIndex(c => c.index === card.index) === -1 ? `‚úÖ(${card.index})${card.name}` : `‚úîÔ∏è(${card.index})${card.name}`) : `‚û°Ô∏è<b>(${card.index})${card.name}</b>`).join('\n')
        const message = `–†–∞—Å—Å—Ç–∞–≤—å—Ç–µ —Å–≤–æ–π –æ—Ç—Ä—è–¥:\n${playerSquadStr}\n\n‚¨õ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–Ω—è—Ç—ã –ø—Ä–µ–∂–¥–µ —á–µ–º –∑–∞–Ω–∏–º–∞—Ç—å ‚¨úÔ∏è`

        const arrowButtons = currentIndex === 1 ? [Markup.button.callback('–î–∞–ª—å—à–µüîú', 'arrange-next')] : [Markup.button.callback('üîô–ù–∞–∑–∞–¥', 'arrange-prev'), Markup.button.callback('–î–∞–ª—å—à–µüîú', 'arrange-next')]

        let idx = 0
        const menu = player.squad.startArrangement.map((array, index) => {

            if (index) idx += array.length

            const row = array.map((item, i) => {
                let square: string
                if (player.game?.players[0] === player) {
                    square = i === 0 || i === 4 ? '‚¨úÔ∏è' : '‚¨õÔ∏è'
                } else {
                    square = i === 0 && index !== 0 || i === 4 && index !== 0 ? '‚¨úÔ∏è' : '‚¨õÔ∏è'
                }

                let itemElement
                if (item) {
                    switch (item.element.trim().toLowerCase()) {
                        case '—Å—Ç–µ–ø–∏':
                            itemElement = '‚òÄÔ∏è'
                            break;
                        case '–ª–µ—Å–∞':
                            itemElement = 'üå≥'
                            break;
                        case '–≥–æ—Ä—ã':
                            itemElement = 'üóª'
                            break;
                        case '–±–æ–ª–æ—Ç–æ':
                            itemElement = 'üåæ'
                            break;
                        case '—Ç—å–º–∞':
                            itemElement = 'üíÄ'
                            break;
                        default:
                            itemElement = '‚öîÔ∏è'
                    }
                }
                return Markup.button.callback(!item ? square : `${itemElement}(${item.arrIndex})`, `ar-card-place_${idx + i}`)
            })
            return row
        }).concat([arrowButtons])
        return { message, menu }
    }

    private parseDecklist(decklist: string): IDeck {
        const result: IDeck = {} as IDeck;
        const matches = decklist.split(',')

        const list: ICard[] = []

        if (matches) {
            result.name = matches[0].trim(); result.list = [];
            const cards = matches.slice(1)

            for (let i = 0; i < cards.length; i++) {
                const [count, name] = cards[i].trim().replace(' ', '|').split('|').map(i => i.toLowerCase().trim());

                list.push({ name: name.trim(), count: parseInt(count) });
            }

            list
                .map((card, index) => {
                    for (let i = index + 1; i < list.length; i++) {
                        const deckCard = list[i]

                        if (deckCard.name === card.name) {
                            card.count += deckCard.count

                            list.splice(i, 1)
                        }

                        if (card.count > 3) {
                            card.count = 3
                        }
                    }

                    return card
                })
                .forEach(card => {
                    if (card != undefined) {
                        result.list.push(card)
                    }
                })
        }

        result.count = result.list.reduce((count: number, card: ICard) => count + card.count, 0)

        return result;
    }

    private generateHandSet(set: string[]) {
        const handSet: string[] = []
        const numbers: number[] = []

        while (handSet.length < 15) {

            const cardNumber = Math.floor(Math.random() * (set.length - 1))

            if (numbers.indexOf(cardNumber) === -1) {

                numbers.push(cardNumber)
                handSet.push(set[cardNumber])
            }
        }

        return handSet
    }

    private parseHand(set: string[]): Card[] {
        const hand: Card[] = set.map(cardName => this.findCardByName(cardName)) as Card[]
        return hand
    }

    private findCardByName(name: string): Card | void {
        const result = cards.find(card => card.name.toLowerCase().trim() === name.toLowerCase().trim())
        return result !== undefined ? JSON.parse(JSON.stringify(result)) : result
    }

    public changeTappedCardStatus(ctx: Context, status = true): void {
        console.log(this)
        const player = this.findGamePlayerByCtx(ctx)
        if (player == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –∏–≥—Ä–æ–∫.</i>')
            return
        }

        const game = player.game
        if (game == undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å/—É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å</i>')
            return
        }

        const cards = this.getCards(ctx, game)

        cards.forEach(card => card.isTapped = status)

        const text = status ? `‚§µÔ∏è<b>${player.name}</b> –∑–∞–∫—Ä—ã–ª –∫–∞—Ä—Ç—ã ${cards.map(c => c.name).join(', ')}.` : `‚§¥Ô∏è<b>${player.name}</b> –æ—Ç–∫—Ä—ã–ª –∫–∞—Ä—Ç—ã ${cards.map(c => c.name).join(', ')}.`
        this.redrawField(ctx, game, text)
    }

    public findGamePlayerByCtx(ctx: Context): IGamePlayer | undefined {
        const userId = ctx.chat?.id
        if (userId == undefined) throw new Error('User not found')

        const room = findRoomForUser(userId)
        if (room == undefined) {
            ctx.replyWithHTML('üö´<i>–í—ã –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ.</i>')
            return
        }

        const game = room.game
        if (game === undefined) {
            ctx.replyWithHTML('üö´<i>–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.</i>')
            return
        }

        return game.players.find(player => player.id === userId)
    }

    private getCards(ctx: Context, game: IGame): IGameCard[] {
        const message = ctx.message as IMessage
        const text = message.text

        const cardCells = text.split(' ').slice(1).map(cell => cell.trim())
        const notFoundCells: string[] = []

        const cards = cardCells
            .map(cellName => {
                let card

                if (!cellName.startsWith('f')) {
                    const cellIndex = cellNames.findIndex(name => name === cellName)

                    const cardRow = Math.floor(cellIndex / 5)
                    const cardCell = cellIndex % 5

                    card = game.battleField[cardRow][cardCell]

                } else {
                    const flierIndex = Number(cellName.slice(1))

                    const playerIndex = Number(!(flierIndex < 4))
                    card = game.players[playerIndex].fliers[flierIndex - 1]
                }

                if (card == undefined) {
                    notFoundCells.push(cellName)
                    return null
                }

                return card
            })
            .filter(card => Boolean(card)) as IGameCard[]

        if (notFoundCells.length) {
            ctx.replyWithHTML(`üö´<i>–ö–ª–µ—Ç–∫–∏/–∫–∞—Ä—Ç—ã –Ω–∞ –∫–ª–µ—Ç–∫–∞—Ö ${notFoundCells.join(', ')} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.</i>`)
        }

        return cards
    }

    private async redrawField(ctx: Context, game: IGame, text: string) {
        game.room.players.concat(game.room.watchers).forEach(user => {
            ctx.telegram.sendMessage(user.id, 'üîò–û–∂–∏–¥–∞–π—Ç–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–ª—è.')
        })
        const fieldStream = await getField(game.battleField, game.players)

        game.room.players.concat(game.room.watchers).forEach(user => {

            if (user.id === game.currentPlayer?.id) {
                ctx.telegram.sendPhoto(user.id, { source: fieldStream }, {
                    caption: `–ü–æ–ª–µ –∏–≥—Ä—ã:\n\n${text}\n\n–•–æ–¥–∏—Ç: ${game.currentPlayer?.name}`, reply_markup: { inline_keyboard: [[Markup.button.callback('–ü–µ—Ä–µ–¥–∞—Ç—å —Ö–æ–¥üîú', 'pass-turn')]] }, parse_mode: 'HTML'
                })
            } else {
                ctx.telegram.sendPhoto(user.id, { source: fieldStream }, { caption: `–ü–æ–ª–µ –∏–≥—Ä—ã:\n\n${text}\n\n–•–æ–¥–∏—Ç: ${game.currentPlayer?.name}`, parse_mode: 'HTML' })
            }
        })
    }
}

function generateRandomRoomName(): string {
    const alph = 'abcdefghigklmnopqrstuvwxuzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    let subStr = ''

    while (subStr.length <= 10) {
        const idx = Math.floor(Math.random() * (alph.length - 1))
        const letter = alph[idx]

        subStr += letter
    }

    return `room${subStr}`
}

export function findRoomForUser(userId: number): IRoom | undefined {
    const curRoom: IRoom | undefined = rooms.find(r =>
        r.players.find(p => p.id === userId) !== undefined
        || r.watchers?.find(w => w.id === userId) !== undefined)

    return curRoom
}

function isPlayer(userId: number, room: IRoom): boolean {
    return room.players.findIndex(p => p.id === userId) !== -1
}

export const findPlayerById = (playerId: number): IPlayer | undefined => players.find(u => u.id === playerId)


const cellNames = [
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'g1',
    'g2',
    'g3',
    'g4',
    'g5'
]